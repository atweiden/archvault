#!/usr/bin/perl6




use v6;




# -----------------------------------------------------------------------------
# main
# -----------------------------------------------------------------------------

multi sub MAIN(
    'install',
    Bool :$augment,
    Str :$disktype,
    Str :$graphics,
    Str :$holograms,
    Str :$holograms-dir,
    Str :$hostname,
    Str :$keymap,
    Str :$locale,
    Str :$partition,
    Str :$processor,
    Str :$rootpass,
    Str :$timezone,
    Str :$username,
    Str :$userpass,
    Str :$vaultname,
    Str :$vaultpass,
)
{
    use Holovault::Config;
    our $CONF;

    # setup with type checking
    {
        my %cfg;

        # if --augment, initialize $CONF.augment to True
        %cfg<augment> = $augment if $augment;

        # if --disktype, initialize $CONF.disk-type to DiskType
        %cfg<disk-type> = Holovault::Config.gen-disk-type($disktype)
            if $disktype;

        # if --graphics, initialize $CONF.graphics to Graphics
        %cfg<graphics> = Holovault::Config.gen-graphics($graphics) if $graphics;

        # if --holograms, initialize $CONF.holograms to space split array
        %cfg<holograms> = Holovault::Config.gen-holograms($holograms)
            if $holograms;

        # if --holograms-dir, ensure dir is readable and initialze
        # $CONF.holograms-dir to IO::Handle
        %cfg<holograms-dir> =
            Holovault::Config.gen-holograms-dir-handle($holograms-dir)
                if $holograms-dir;

        # if --hostname, initialize $CONF.hostname to HostName
        %cfg<host-name> = Holovault::Config.gen-host-name($hostname)
            if $hostname;

        # if --keymap, initialize $CONF.keymap to Keymap
        %cfg<keymap> = Holovault::Config.gen-keymap($keymap) if $keymap;

        # if --locale, initialize $CONF.locale to Locale
        %cfg<locale> = Holovault::Config.gen-locale($locale) if $locale;

        # if --vaultname, initialize $CONF.vault-name to VaultName
        %cfg<vault-name> = Holovault::Config.gen-vault-name($vaultname)
            if $vaultname;

        # if --vaultpass, initialize $CONF.vault-pass to VaultPass
        %cfg<vault-pass> = Holovault::Config.gen-vault-pass($vaultpass)
            if $vaultpass;

        # if --partition, initialize $CONF.partition to Partition
        %cfg<partition> = $partition if $partition;

        # if --processor, initialize $CONF.processor to Processor
        %cfg<processor> = Holovault::Config.gen-processor($processor)
            if $processor;

        # if --rootpass, initialize $CONF.root-pass-digest to sha512 digest
        %cfg<root-pass-digest> = Holovault::Config.gen-digest($rootpass)
            if $rootpass;

        # if --timezone, initialize $CONF.timezone to Timezone
        %cfg<timezone> = Holovault::Config.gen-timezone($timezone) if $timezone;

        # if --username, initialize $CONF.user-name to UserName
        %cfg<user-name> = Holovault::Config.gen-user-name($username)
            if $username;

        # if --userpass, initialize $CONF.user-pass-digest to sha512 digest
        %cfg<user-pass-digest> = Holovault::Config.gen-digest($userpass)
            if $userpass;

        # instantiate global config, prompting for user input as needed
        $CONF = Holovault::Config.new(|%cfg);
    }

    say $CONF.perl;

    # secure disk configuration
    sub configure-disk()
    {
        # partition disk with gdisk
        sub mkdisk(Str:D :$partition = $CONF.partition)
        {
            # erase existing partition table
            # create 2MB EF02 BIOS boot sector
            # create 128MB sized partition for /boot
            # create max sized partition for LUKS encrypted volume
            shell "sgdisk --zap-all --clear --mbrtogpt \\
                          --new=1:0:+2M --typecode=1:EF02 \\
                          --new=2:0:+128M --typecode=2:8300 \\
                          --new=3:0:0 --typecode=3:8300 $partition";
        }

        # partition disk
        mkdisk();

        # create vault with cryptsetup
        sub mkvault(
            Str:D :$partition = $CONF.partition,
            Str:D :$vault-name = $CONF.vault-name
        )
        {
            # target partition for vault
            my Str $partition-vault = $partition ~ "3";

            # load kernel modules for cryptsetup
            shell 'modprobe dm_mod dm-crypt';

            # was LUKS encrypted volume password given in cmdline flag?
            if my Str $vault-pass = $CONF.vault-pass
            {
                # make LUKS encrypted volume without prompt for vault password
                shell "expect <<'EOF'
                         spawn cryptsetup --cipher aes-xts-plain64 \\
                                          --key-size 512           \\
                                          --hash sha512            \\
                                          --iter-time 5000         \\
                                          --use-random             \\
                                          --verify-passphrase      \\
                                          luksFormat $partition-vault
                         expect \"Are you sure*\" \{ send \"YES\r\" \}
                         expect \"Enter*\" \{ send \"$vault-pass\r\" \}
                         expect \"Verify*\" \{ send \"$vault-pass\r\" \}
                         expect eof
                       EOF";

                # open vault without prompt for vault password
                shell "expect <<'EOF'
                         spawn cryptsetup luksOpen $partition-vault $vault-name
                         expect \"Enter*\" \{ send \"$vault-pass\r\" \}
                         expect eof
                       EOF";
            }
            else
            {
                while True
                {
                    # hacky output to inform user of password entry
                    # context until i can implement advanced expect
                    # cryptsetup luksFormat program output interception
                    say "Creating LUKS vault...";

                    # create LUKS encrypted volume, prompt user for
                    # vault password
                    my Proc $cryptsetup-luks-format =
                        shell "expect -c 'spawn cryptsetup \\
                                              --cipher aes-xts-plain64 \\
                                              --key-size 512           \\
                                              --hash sha512            \\
                                              --iter-time 5000         \\
                                              --use-random             \\
                                              --verify-passphrase      \\
                                              luksFormat $partition-vault;
                                          expect \"Are you sure*\" \{
                                            send \"YES\r\"
                                          \};
                                          interact;
                                          catch wait result;
                                          exit [lindex \$result 3]'";

                    # loop until passphrases match
                    # - returns exit code 0 if success
                    # - returns exit code 1 if SIGINT
                    # - returns exit code 2 if wrong password
                    last if $cryptsetup-luks-format.exitcode == 0;
                }

                while True
                {
                    # hacky output to inform user of password entry
                    # context until i can implement advanced expect
                    # cryptsetup luksOpen program output interception
                    say "Opening LUKS vault...";

                    # open vault with prompt for vault password
                    my Proc $cryptsetup-luks-open =
                        shell "cryptsetup luksOpen $partition-vault \\
                                 $vault-name";

                    # loop until passphrase works
                    # - returns exit code 0 if success
                    # - returns exit code 1 if SIGINT
                    # - returns exit code 2 if wrong password
                    last if $cryptsetup-luks-open.exitcode == 0;
                }
            }
        }

        # create vault
        mkvault();

        # create and mount btrfs volumes on open vault
        sub mkbtrfs(Str:D :$vault-name = $CONF.vault-name)
        {
            # create btrfs filesystem on opened vault
            shell "mkfs.btrfs /dev/mapper/$vault-name";

            # mount main btrfs filesystem on open vault
            '/mnt2'.IO.mkdir;
            shell "mount \\
                     -t btrfs \\
                     -o rw,noatime,nodiratime,compress=lzo,space_cache \\
                     /dev/mapper/$vault-name /mnt2";

            # create btrfs subvolumes
            chdir '/mnt2';
            shell 'btrfs subvolume create @';
            shell 'btrfs subvolume create @home';
            shell 'btrfs subvolume create @opt';
            shell 'btrfs subvolume create @srv';
            shell 'btrfs subvolume create @tmp';
            shell 'btrfs subvolume create @usr';
            shell 'btrfs subvolume create @var';
            chdir '/';

            # mount btrfs subvolumes, starting with root / ('')
            my Str @btrfs-dirs = '', 'home', 'opt', 'srv', 'tmp', 'usr', 'var';
            for @btrfs-dirs -> $btrfs-dir
            {
                "/mnt/$btrfs-dir".IO.mkdir;
                shell "mount \\
                         -t btrfs \\
                         -o rw, \\
                            noatime, \\
                            nodiratime, \\
                            compress=lzo, \\
                            space_cache, \\
                            subvol=@$btrfs-dir \\
                         /dev/mapper/$vault-name /mnt/$btrfs-dir";
            }

            # unmount /mnt2 and remove
            shell 'umount /mnt2';
            '/mnt2'.IO.rmdir;
        }

        # create and mount btrfs volumes
        mkbtrfs();

        # create and mount boot partition
        sub mkbootpart(Str:D :$partition = $CONF.partition)
        {
            # target partition for boot
            my Str $partition-boot = $partition ~ 2;

            # create ext2 boot partition
            shell "mkfs.ext2 $partition-boot";

            # mount ext2 boot partition in /mnt/boot
            '/mnt/boot'.IO.mkdir;
            shell "mount $partition-boot /mnt/boot";
        }

        # create boot partition
        mkbootpart();
    }

    # bootstrap initial chroot with pacstrap
    sub pacstrap-base()
    {
        # base packages
        my Str @packages-base =
            'abs',
            'arch-install-scripts',
            'base',
            'base-devel',
            'bash-completion',
            'btrfs-progs',
            'ca-certificates',
            'cronie',
            'dhclient',
            'dialog',
            'dnscrypt-proxy',
            'ed',
            'ethtool',
            'expect',
            'gptfdisk',
            'grub-bios',
            'haveged',
            'iproute2',
            'iptables',
            'iw',
            'kbd',
            'kexec-tools',
            'net-tools',
            'openresolv',
            'openssh',
            'python2',
            'reflector',
            'rsync',
            'sshpass',
            'systemd-swap',
            'tmux',
            'unzip',
            'wget',
            'wireless_tools',
            'wpa_actiond',
            'wpa_supplicant',
            'zip',
            'zsh';

        # https://www.archlinux.org/news/changes-to-intel-microcodeupdates/
        push @packages-base, 'intel-ucode' if $CONF.processor ~~ 'intel';

        # download and install packages with pacman in chroot
        shell "pacstrap /mnt @packages-base[]";
    }

    # secure user configuration
    sub configure-users()
    {
        # updating root password...
        my Str $root-pass-digest = $CONF.root-pass-digest;
        shell "arch-chroot /mnt usermod -p '$root-pass-digest' root";

        # creating new user with password from secure password digest...
        my Str $user-name = $CONF.user-name;
        my Str $user-pass-digest = $CONF.user-pass-digest;
        shell "arch-chroot /mnt useradd \\
                                  -m \\
                                  -p '$user-pass-digest' \\
                                  -s /bin/bash \\
                                  -g users \\
                                  -G audio, \\
                                     games, \\
                                     log, \\
                                     lp, \\
                                     network, \\
                                     optical, \\
                                     power, \\
                                     scanner, \\
                                     storage, \
                                     video, \\
                                     wheel \\
                                  $user-name";
    }

    sub customize()
    {
        # launch fully interactive Bash console, type 'exit' to exit
        shell "expect -c 'spawn /bin/bash; interact'" if $CONF.augment;
    }
}




# -----------------------------------------------------------------------------
# utilities
# -----------------------------------------------------------------------------

multi sub MAIN('ls', 'holograms', Str :$holograms-dir)
{
    .say for Holovault::Config.ls-holograms(:holograms-dir($holograms-dir));
}
multi sub MAIN('ls', 'keymaps') { .say for Holovault::Config.ls-keymaps; }
multi sub MAIN('ls', 'locales') { .say for Holovault::Config.ls-locales; }
multi sub MAIN('ls', 'partitions') { .say for Holovault::Config.ls-partitions; }
multi sub MAIN('ls', 'timezones') { .say for Holovault::Config.ls-timezones; }




# -----------------------------------------------------------------------------
# version
# -----------------------------------------------------------------------------

constant $VERSION = "0.0.1";
multi sub MAIN(Bool:D :$version! where *.so) { say $VERSION; exit; }




# -----------------------------------------------------------------------------
# usage
# -----------------------------------------------------------------------------

sub USAGE()
{
    constant $HELP = q:to/EOF/;
    Usage:
      holovault [-h]
      holovault --holograms="skreltoi amnesia"        \
                --username="live"                     \
                --userpass="your new user's password" \
                --rootpass="your root password"       \
                --vaultname="luckbox"                 \
                --vaultpass="your vault password"     \
                --hostname="luckbox"                  \
                --partition="/dev/sdb"                \
                --processor="other"                   \
                --graphics="intel"                    \
                --disktype="usb"                      \
                --locale="en_US"                      \
                --keymap="us"                         \
                --timezone="America/Los_Angeles"      \
                --augment                             \
                install

    positional arguments:
      <command>
        install                   Bootstrap Arch system with Holo
        ls                        List discovered holograms, keymaps, locales,
                                  partitions, timezones

    optional arguments:
      --augment                   drop to Bash console mid-execution
      --disktype=DISK_TYPE        hard drive type
      --graphics=GRAPHICS         graphics card type
      --holograms=HOLOGRAMS       holograms (space separated)
      --holograms-dir=DIR_PATH    path to dir containing hologram subdirs
      --hostname=HOSTNAME         hostname
      --keymap=KEYMAP             keymap
      --locale=LOCALE             locale
      --partition=DEVICE_PATH     partition target for install
      --processor=PROCESSOR       processor type
      --rootpass=PASSWORD         root password
      --timezone=TIMEZONE         timezone
      --username=USERNAME         user name
      --userpass=PASSWORD         user password
      --vaultname=VAULT_NAME      vault name
      --vaultpass=PASSWORD        vault password
      --version                   print version and exit
    EOF
    say $HELP.trim;
}

# vim: ft=perl6
